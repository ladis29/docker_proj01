curl -L https://github.com/docker/compose/releases/download/1.21.0/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose
chmod +x /usr/local/bin/docker-compose
ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose
-------------------------------------------------------------------------------------------------------------------------------------------
sudo yum install docker
sudo -i
groupadd docker
usermod -aG docker ladis
systemctl enable --now docker
-------------------------------------------------------------------------------------------------------------------------------------------
docker search [img] - Procura a imagem do container no repositório padrão

docker pull [img] - baixa a imagem do container do repositório padrão

docker images - exibe as imagens de container baixadas no equipamento

docker inspect [img] - Mostra as informações das imagens baixadas no formato JSON

docker run [img] - Cria o container

docker run -d --name MyWeb2 nginx - (docker run ... nginx)Cria um container nginx (-d)rodando em background (--name MyWeb1) com o nome MyWeb1

docker ps - Mostra os container que estão rodando no sistema

docker ps -a - Mostra os container que rodaram no sistema

docker exec -it LifeCicle1 /bin/bash - Executa o shel de maneira interativa no container LifeCicle1 que está rodando nginx
-------------------------------------------------------------------------------------------------------------------------------------------

docker rmi centos:centos6 - Deleta a imagem do centos baseada na versão 6 que eu tinha no meu repositório local(desde que a imagem não possua container no sistema)

docker rmi -f [img] - Força a remoção de uma imagem que tem container criado(ativo ou não)

docker rm [Container ID] - remove um container criado (ex: docker rm d196584b675f)

docker run -d --name=WebServer1 -P nginx:latest - o "-P" significa que a porta que estiver aberta no meu container deverá ser disponibilizada pelo hospedeiro através de qualquer porta disponível entre as mais de 32000 portas

docker run -d -p 8080:80 --name=WebServer2 nginx:latest - A instrução -p serve para especificar a porta a ser usaada no servidor hospedeiro, neste caso a porta 8080 do meu hospedeiro será linkada à porta 80 do meu container

docker run -d -p 8080:80 --name=WebServer3 -v /mnt/data nginx:latest - A instrução "-v /mnt/data" mapeia o diretório "/mnt/data" no momento da criação do meu container para que seja usado pelo mesmo

docker run -d -p 8080:80 --name=WebServer3 -v /root/www:/usr/share/nginx/html nginx:latest - Neste caso eu estou dizendo para o docker usar o diretório local "/root/www/" no lugar do "/usr/share/nginx/html" (Que seria o diretório padrão do nginx) no momento da criação do container.

docker rm `docker ps -a -q` - Apaga todos os container inativos no hospedeiro
-------------------------------------------------------------------------------------------------------------------------------------------
docker build -t ladis29/myapache . - Cria uma imagem docker baseado no dockerfile criado anteriormente com o nome "ladis29/myapache" no diretório atual

docker commit 70b4cad3ef35 spacebones:thewebsite - após fazer o deploy da imagem e deixar ela preparada do jeito que eu preciso eu posso fazer o commit e criar uma imagem a partir dessa imagem usando o CONTAINER_ID(70b4cad3ef35) e informando o nome e a tag da nova imagem(spacebones:thewebsite)
-------------------------------------------------------------------------------------------------------------------------------------------
docker network inspect bridge -  verifica as informações das bridges networks existentes

docker network ls - verifica as conexões de rede dos containers docker

docker network create --driver=bridge --subnet=192.168.10.0/24 --gateway=192.168.10.250 borkspace - cria a bridge com as características informadas e o nome boskspace

docker network inspect borkspace - verifica as configurações de rede do container "borkspace"
-------------------------------------------------------------------------------------------------------------------------------------------
docker volume create missionstatus

docker volume ls

docker run -d -p 80:80 --name fishin-mission --mount source=missionstatus,target=/usr/local/apache2/htdocs httpd

-------------------------------------------------------------------------------------------------------------------------------------------

Configurar Docker para usar o syslog

Configure syslog.
You will need to open rsyslog.conf and make a few changes:

 vim /etc/rsyslog.conf
Uncomment the two UDP syslog receptions:

#$ModLoad imudp
#$UDPServerRun 514
to

$ModLoad imudp
$UDPServerRun 514
help
Configure Docker to use syslog.
Create the daemon.json file.

vim /etc/docker/daemon.json
Add the following content.

{
  "log-driver": "syslog",
  "log-opts": {
    "syslog-address": "udp://PRIVATE_IP:514"
  }
}
help
Create a container using syslog.
Create a container called syslog-logging using the httpd image.

docker container run -d --name syslog-logging httpd
help
Create a container using a JSON file.
Create a container that uses the JSON file for logging.

docker container run -d --name json-logging --log-driver json-file httpd
help
Verify that the `syslog-logging` container is sending its logs to syslog.
Make sure that the syslog-logging container is logging to syslog by checking the message log file:

tail /var/log/message
help
Verify that the `json-logging` container is sending its logs to the JSON file.
Execute docker logs for the json-logging container.

 docker logs json-logging

-------------------------------------------------------------------------------------------------------------------------------------------

Login no docker hub:
- docker login

- docker build -t ladis29/express -f Dockerfile . - Cria uma imagem local vinculada à minha conta no docker Hub

- docker push ladis29/express - Envia a imagem criada para o docker hub

- cria e roda um container watchtower

-------------------------------------------------------------------------------------------------------------------------------------------
METADATAS ON DOCKERFILES

vim Dockerfile

#Início do dockerfile

FROM node

LABEL maintainer="ladis29@gmail.com"

ARG BUILD_VERSION
ARG BUILD_DATE
ARG APPLICATION_NAME

LABEL org.label-schema.build-date=$BUILD_DATE
LABEL org.label-schema.applicaiton=$APPLICATION_NAME
LABEL org.label-schema.version=$BUILD_VERSION

RUN mkdir -p /var/node
ADD weather-app/ /var/node/
WORKDIR /var/node
RUN npm install
EXPOSE 3000
CMD ./bin/www

#fim dockerfile

docker build -t ladis29/weather-app --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ') --build-arg APPLICATION_NAME=weather-app --build-arg BUILD_VERSION=v1.0  -f Dockerfile .

docker push ladis29/weather-app
-------------------------------------------------------------------------------------------------------------------------------------------

Load Balancing containers

Create a Docker Compose file.
The containers of your docker-compose.yml should look like the following:

vim docker-compose.yml
---
version: '3.2'
services:
  weather-app1:
      build: ./weather-app
      tty: true
      networks:
       - frontend
  weather-app2:
      build: ./weather-app
      tty: true
      networks:
       - frontend
  weather-app3:
      build: ./weather-app
      tty: true
      networks:
       - frontend

  loadbalancer:
      build: ./load-balancer
      image: nginx
      tty: true
      ports:
       - '80:80'
      networks:
       - frontend

networks:
  frontend:
---
Update `nginx.conf`.
The contents of your nginx.conf file should look like the following:
---
events { worker_connections 1024; }

http {
  upstream localhost {
    server weather-app1:3000;
    server weather-app2:3000;
    server weather-app3:3000;
  }
  server {
    listen 80;
    server_name localhost;
    location / {
      proxy_pass http://localhost;
      proxy_set_header Host $host;
    }
  }
}
---
Execute `docker-compose up`.
Execute a docker-compose up:

docker-compose up --build -d
help
Create a Docker service using Docker Swarm.
Create a Docker service by executing the following command:

docker service create --name nginx-app --publish published=8080,target=80 --replicas=2 nginx
-------------------------------------------------------------------------------------------------------------------------------------------
Monitoring Containers with Prometheus

Create a `prometheus.yml` file.
In the root directory, create prometheus.yml.

scrape_configs:
- job_name: cadvisor
  scrape_interval: 5s
  static_configs:
  - targets:
    - cadvisor:8080
help
Create the Prometheus services.
Create a docker-compose.yml file:

version: '3'
services:
  prometheus:
    image: prom/prometheus:latest
    container_name: prometheus
    ports:
      - 9090:9090
    command:
      - --config.file=/etc/prometheus/prometheus.yml
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
    depends_on:
      - cadvisor

  cadvisor:
    image: google/cadvisor:latest
    container_name: cadvisor
    ports:
      - 8080:8080
    volumes:
      - /:/rootfs:ro
      - /var/run:/var/run:rw
      - /sys:/sys:ro
      - /var/lib/docker:/var/lib/docker:ro
Stand up the environment.

docker-compose up -d
help
Create `stats.sh`.
Create stats.sh in /root.

 docker stats --format "table {{.Name}} {{.ID}} {{.MemUsage}} {{.CPUPerc}}"
Make sure the file can be executed.

 chmod a+x stats.sh
Execute the script.

 ./stats.sh
When you're finished, exit by pressing Ctrl+C.

help
Create a `docker-compose.yml` file.
Create a docker-compose.yml file the root directory:

vi ~/docker-compose.yml
Add the following contents:

version: '3'
services:
  prometheus:
    image: prom/prometheus:latest
    container_name: prometheus
    ports:
      - 9090:9090
    command:
      - --config.file=/etc/prometheus/prometheus.yml
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml:ro
    depends_on:
      - cadvisor
  cadvisor:
    image: google/cadvisor:latest
    container_name: cadvisor
    ports:
      - 8080:8080
    volumes:
      - /:/rootfs:ro
      - /var/run:/var/run:rw
      - /sys:/sys:ro
      - /var/lib/docker/:/var/lib/docker:ro

-------------------------------------------------------------------------------------------------------------------------------------------

Setting Up a Kubernetes Cluster with Docker

Add the Kubernetes repo:

vim /etc/yum.repos.d/kubernetes.repo
[kubernetes]
name=Kubernetes
baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64
enabled=1
gpgcheck=1
repo_gpgcheck=1
gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg
exclude=kube*


Disable SELinux:
setenforce 0


Install Kubernetes:
yum install -y kubelet-1.11.3 kubeadm-1.11.3 kubectl-1.11.3 --disableexcludes=kubernetes

systemctl enable kubelet && systemctl start kubelet



Set net.bridge.bridge-nf-call-iptables to 1 in your sysctl:

vim /etc/sysctl.d/k8s.conf
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1


Reload:
sysctl --system

On only the second and third nodes:

Execute the join command that is generated when the master node is initialized via kubeadm.



Initialize the master node:

kubeadm init --pod-network-cidr=10.0.0.0/16 --kubernetes-version=v1.11.3
mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config


Copy the join token that was output from the kubeadm init command, or execute this command to create a new one:

kubeadm token create --print-join-command

You will need this token to add the second and third servers to the cluster.

Verify if all nodes are listed
kubectl get nodes



Create pod.yml:

vim pod.yml
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod-demo
  labels:
    app: nginx-demo
spec:
  containers:
  - image: nginx:latest
    name: nginx-demo
    ports:
    - containerPort: 80
    imagePullPolicy: Always


Create the pod:

kubectl create -f pod.yml




Create service.yml:

vim service.yml

kind: Service
apiVersion: v1
metadata:
  name: service-demo
spec:
  selector:
    app: nginx-demo
  ports:
  - protocol: TCP
    port: 80
    targetPort: 80
  type: NodePort



Create the service:

kubectl create -f service.yml
-------------------------------------------------------------------------------------------------------------------------------------------

